"""Sparse Sign sketch implementation for matrix sketching.

This module provides a concrete implementation of the Sketch class
using sparse sign matrices for sketching.

Typical usage example:

  sparse_sketch = Sparse("left", 100, 1000, device)
  sketched_matrix = sparse_sketch.apply_left(matrix)
"""

import torch

from .enums import _SketchSide
from .sketch import Sketch


class Sparse(Sketch):
    """Sparse Sign sketch class for matrix sketching.

    This class implements the Sketch abstract base class using
    sparse sign matrices for the sketching process.

    Attributes:
        Inherited from Sketch class.
    """

    def __init__(self, mode, sketch_size, matrix_dim, dtype, device):
        """Initializes the Sparse Sign sketch with given parameters."""
        super().__init__(mode, sketch_size, matrix_dim, dtype, device)

    def _generate_embedding(self) -> torch.Tensor:
        """Generates the sparse sign embedding matrix for sketching.

        This method creates a sparse sign matrix by randomly placing
        +1 or -1 values in a sparse pattern. The sparsity is controlled
        by the parameter zeta, which determines the number of non-zero
        entries per column.

        Returns:
            A torch.Tensor representing the sparse sign embedding matrix.

        Note:
            The sparse sign matrix is generated by:
            1. Determining the sparsity factor zeta.
            2. Generating random +1/-1 values.
            3. Randomly placing zete of these values in each column.
            4. Scaling the matrix by 1/sqrt(zeta).
            The normalization is such that: Omega.T @ Omega
            is an expected isometry
        """
        zeta = 8 if self.s >= 8 else self.s

        # Initialize S as a zero matrix
        Omega_mat = torch.zeros((self.s, self.d), dtype=self.dtype, device=self.device)

        # Generate random +1/-1 values for zeta entries in each column
        b = torch.bernoulli(
            0.5 * torch.ones((zeta, self.d), dtype=self.dtype, device=self.device)
        )  # Bernoulli(0.5)
        z = 2 * b - 1  # Convert to +1/-1

        # Generate random row indices for each non-zero entry in each column
        row_indices = torch.randint(
            self.s, (zeta, self.d), device=self.device
        )  # Random row indices

        # Scatter update: place z values in S at the appropriate row indices
        Omega_mat.scatter_(0, row_indices, z)  # In-place scatter

        # Scale S
        Omega_mat = Omega_mat * (zeta**-0.5)
        if self.mode == _SketchSide.RIGHT:
            Omega_mat = Omega_mat.T

        return Omega_mat
